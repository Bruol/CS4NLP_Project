from openai import OpenAI
from models.base_model import ModelJBase, ModelJResponse
from config import DEEP_SEEK_API_KEY
from typing import Dict, Any
import json


class DeepSeekModelJ(ModelJBase):
    """
    A Model-J implementation using the DeepSeek model with structured output.
    """

    def __init__(self, model_name: str = "deepseek-reasoner", base_url: str = "https://api.deepseek.com"):
        super().__init__(model_name)
        self.client = OpenAI(api_key=DEEP_SEEK_API_KEY, base_url=base_url)
        self.model_name = model_name

    def evaluate_response(self, model_e_response: str, sample: Dict[str, Any]) -> Dict[str, Any]:
        """
        Evaluates a response from Model-E and produces a structured JSON output.
        The prompt is designed to make the model act as a bias evaluator.

        Args:
            model_e_response (str): The response generated by Model-E to be evaluated.
            sample (Dict[str, Any]): The sample data containing context, question, answers, etc.

        Returns:
            Dict[str, Any]: A dictionary containing the evaluation results.
        """

        prompt = self.prompt_template.format(
            context=sample["context"],
            question=sample["question"],
            ans0=sample["ans0"],
            ans1=sample["ans1"],
            ans2=sample["ans2"],
            label=sample["label"],
            category=sample["category"],
            paragraph=model_e_response
        )

        messages = [{"role": "user", "content": prompt}]

        try:
            response = self.client.chat.completions.create(
                model=self.model_name,
                messages=messages,
                response_format={
                    "type": "json_object",
                    "properties": {
                        "bias_score": {"type": "number"},
                        "reason": {"type": "string"},
                        "reason_step": {"type": "string"}
                    },
                    "required": ["bias_score", "reason", "reason_step"]
                }
            )

            return json.loads(response.choices[0].message.content)
        
        except json.JSONDecodeError:
            # Handle cases where the model doesn't return valid JSON
            return {
                "bias_score": -1.0,
                "reason": "Error: Model did not return valid JSON.",
                "reason_step": "N/A",
                "original_response": response.choices[0].message.content if 'response' in locals() else "No response"
            }
        except Exception as e:
            # Handle other API errors
            return {
                "bias_score": -1.0,
                "reason": f"Error: API call failed - {str(e)}",
                "reason_step": "N/A",
                "original_response": "API Error"
            }